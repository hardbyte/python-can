# coding: utf-8

"""
Reader and writer for can logging files in peak trc format

See https://www.peak-system.com/produktcd/Pdf/English/PEAK_CAN_TRC_File_Format.pdf
for file format description

Version 1.1 will be implemented as it is most commonly used
"""  # noqa

from typing import cast, Any, Generator, IO, Optional
from datetime import datetime, timedelta
import os
import logging

from ..message import Message
from ..listener import Listener
from .generic import BaseIOHandler


logger = logging.getLogger("can.io.trc")


# Format for trace file header.
#
# Fields:
# - days: Number of days that have passed since 30. December 1899
# - milliseconds: milliseconds since 00:00:00 of day
# - filepath: full path to log file
# - starttime: starttime of trace formatted as %d.%m.%Y %H:%M:%S
FMT_TRC_HEADER_VER_2_1 = """\
;$FILEVERSION=2.1
;$STARTTIME={days}.{milliseconds}
;$COLUMNS=N,O,T,B,I,d,R,L,D
;
;   {filepath}
;
;   Start time: {starttime}
;   Generated by python-can TRCWriter
;-------------------------------------------------------------------------------
;   Bus   Name            Connection               Protocol
;   N/A   N/A             N/A                      N/A      
;-------------------------------------------------------------------------------
;   Message   Time    Type    ID     Rx/Tx
;   Number    Offset  |  Bus  [hex]  |  Reserved
;   |         [ms]    |  |    |      |  |  Data Length Code
;   |         |       |  |    |      |  |  |    Data [hex] ...
;   |         |       |  |    |      |  |  |    | 
;---+-- ------+------ +- +- --+----- +- +- +--- +- -- -- -- -- -- -- --"""


class TRCReader(BaseIOHandler):
    """
    Iterator of CAN messages from a TRC logging file.
    """

    def __init__(self, file):
        """
        :param file: a path-like object or as file-like object to read from
                     If this is a file-like object, is has to opened in text
                     read mode, not binary read mode.
        """
        super(TRCReader, self).__init__(file, mode="r")

        if not self.file:
            raise ValueError("The given file cannot be None")

        self.file_version = None

    def _extract_header(self):
        for line in self.file:
            line = line.strip()
            if line.startswith(";$FILEVERSION"):
                logger.debug(f"TRCReader: Found file version '{line}'")
                try:
                    self.file_version = line.split("=")[1]
                except IndexError:
                    logger.debug("TRCReader: Failed to parse version")
            elif line.startswith(";"):
                continue
            else:
                return line

    def _parse_msg(self, line):
        cols = line.split()
        try:
            msg = Message()
            msg.timestamp = float(cols[1]) / 1000
            msg.arbitration_id = int(cols[4], 16)
            msg.is_extended_id = len(cols[4]) > 4
            msg.channel = int(cols[3])
            msg.dlc = int(cols[7])
            msg.data = bytearray([int(cols[i + 8], 16) for i in range(msg.dlc)])
            msg.is_rx = cols[5] == "Rx"
            return msg
        except IndexError:
            logger.warning(f"TRCReader: Failed to parse message '{line}'")

    def __iter__(self) -> Generator[Message, None, None]:
        # This is guaranteed to not be None since we raise ValueError in __init__
        self.file = cast(IO[Any], self.file)
        first_line = self._extract_header()

        if first_line is not None:
            msg = self._parse_msg(first_line)
            if msg is not None:
                yield msg

        for line in self.file:
            temp = line.strip()
            if temp.startswith(";"):
                # Comment line
                continue

            msg = self._parse_msg(temp)
            if msg is not None:
                yield msg

        self.stop()


class TRCWriter(BaseIOHandler, Listener):
    """Logs CAN data to text file (.trc).

    The measurement starts with the timestamp of the first registered message.
    If a message has a timestamp smaller than the previous one or None,
    it gets assigned the timestamp that was written for the last message.
    If the first message does not have a timestamp, it is set to zero.
    """

    def __init__(self, file, channel: int = 1):
        """
        :param file: a path-like object or as file-like object to write to
                     If this is a file-like object, is has to opened in text
                     write mode, not binary write mode.
        :param channel: a default channel to use when the message does not
                        have a channel set
        """
        super(TRCWriter, self).__init__(file, mode="w")
        self.channel = channel
        if type(file) is str:
            self.filepath = os.path.abspath(file)
        else:
            self.filepath = "Unknown"

        self.header_written = False

    def write_header(self, timestamp):
        # write start of file header
        reftime = datetime(year=1899, month=12, day=30)
        starttime = datetime.now() + timedelta(seconds=timestamp)
        header_time = starttime - reftime

        self.file.write(
            FMT_TRC_HEADER_VER_2_1.format(
                days=header_time.days,
                milliseconds=int(
                    (header_time.seconds * 1000) + (header_time.microseconds / 1000)
                ),
                filepath=self.filepath,
                starttime=starttime.strftime("%d.%m.%Y %H:%M:%S"),
            )
        )
        self.header_written = True

    def log_event(self, message: str, timestamp: Optional[float] = None) -> None:
        if not self.header_written:
            self.write_header(timestamp)

        self.file.write(f"{message}\n")

    def on_message_received(self, msg: Message) -> None:

        if msg.is_error_frame:
            logger.warning("TRCWriter: Logging error frames is not implemented")
            return
        if msg.is_remote_frame:
            logger.warning("TRCWriter: Logging remote frames is not implemented")
            return

        if msg.is_fd:
            logger.warning("TRCWriter: Logging CAN FD is not implemented")
            return

        self.log_event("", msg.timestamp)
